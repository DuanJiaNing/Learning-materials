## java内存管理
参考文章：[Java内存管理：深入Java内存区域](https://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html)
### 1. 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，创建以及销毁时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。
![这里写图片描述](http://upload-images.jianshu.io/upload_images/7460499-336c86b462c600f7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
<center><b>java-运行时数据区域</b></center>
可以看到上图很准确的将**线程私有数据区域**和**线程共享区域**区分开。
#### 1.1 程序计数器
程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的<b>行号指示器</b>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），<u>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</u>

**每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。**
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
#### 1.2 栈（Java虚拟机栈）
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是**线程私有**的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：
<p>每个方法被执行的同时会创建一个**栈帧（Stack Frame）**用于存储局部变量表、操作栈、动态链接、方法出口等信息。<u>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</u>

该区域在无法申请到足够内存时会抛出StackOverflowError和OutOfMemoryError异常。
#### 1.3 本地方法栈
本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<u>本地方法栈则是为虚拟机使用到的Native方法服务</u>。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

会抛出StackOverflowError和OutOfMemoryError异常。
#### 1.4 堆
对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的**内存中最大的一块**。Java堆是**被所有线程共享**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：<u>所有的对象实例以及数组都要在堆上分配</u>.
<p>但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>

**Java堆是垃圾收集器管理的主要区域**，因此很多时候也被称做“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。

会出OutOfMemoryError异常。
#### 1.5 方法区
方法区（Method Area）与Java堆一样，是**各个线程共享的内存区域**，它<u>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</u>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。

这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻。

会抛出OutOfMemoryError异常。

##### 1.5.1 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是**常量池（Constant Pool Table）**，用于存放编译期生成的各种<u>字面量和符号引用</u>，这部分内容将在类加载后存放到方法区的运行时常量池中。具备动态性（如String类的intern()方法）。

会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
### 2. 对象访问
在Java语言中，对象访问是如何进行的？
对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java栈、Java堆、方法区这三个最重要内存区域。

如：

```
Object obj = new Object();
```
假设这句代码出现在方法体中
1. 那“Object obj”这部分的语义将会反映到<b>Java栈的本地变量表</b>中，作为一个reference类型数据出现。
2.	而“new Object()”这部分的语义将会反映到**Java堆**中，形成一块存储了Object类型所有实例数据值的结构化内存，这块内存的长度是不固定的。
3.	在Java堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在**方法区**中。

### 3. 常量池分类
参考文章：[Java中几种常量池的区分](https://www.cnblogs.com/holos/p/6603379.html )
#### 3.1 全局字符串池
string pool也有叫做string literal pool
<p>全局字符串池里的内容是<u>在类加载完成，经过验证，准备阶段<b>之后</b></u>在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<b>string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放。</b>），只有一份， 被所有类，所有线程共享。</p>
#### 3.2 Class文件常量池
.java文件被编译为.class文件时产生。存在于**文件**中。
class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于**存放编译器生成的各种字面量和符号引用。**

<u>字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</u>

一般包括下面三种：
1.	类和接口的全限定名
2.	字段的名称和描述符
3.	方法的名称和描述符
#### 3.3 运行时常量池
runtime constant pool
当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？

jvm在执行某个类的时候，必须经过**加载、连接、初始化**，而连接又包括**验证、准备、解析**三个阶段。而<u>当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中</u>，由此可知，运行时常量池也是每个类都有一个。

<u>class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用</u>，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

#### 3.4 小结
<p>全局字符串池在每个JVM中只有一份，存放的是字符串常量的引用值。</p>
<p>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</p>
<p>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p>

### 4. 8种基本类型的包装类与常量池
参考文章：[java常量池概念，String，Integer等包装类对常量池的应用](http://blog.csdn.net/chen1280436393/article/details/51768761 )

Java中基本类型的包装类大部分实现了常量池技术，这些类是：**Byte Short Integer Long Character Boolean**，另外**两个浮点类型的包装类则没有实现**。另外Byte、Short、Integer、Long、Character这5种包装类也只有在对应的**值小于127时**才能使用常量池。String也实现了常量池技术。

JVM 会自动维护八种基本类型的常量池，int常量池中初始化有** -128~127 **的数值（只维护-128~127的数值，范围外的不放在常量池中），所以当Integer=127时，在自动装箱过程中是取常量池中的数值，当Integer=128时，不在范围内，所以会new一个对象，而不是从常量池中返回。




